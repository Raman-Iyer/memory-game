{"version":3,"sources":["fontawesome.js","components/Tile.js","components/Board.js","data/iconList.js","helpers/initializeBoard.js","helpers/isMatchFound.js","helpers/calculateWinner.js","App.js","serviceWorker.js","index.js"],"names":["library","add","faBomb","faBiohazard","faAngry","faAnkh","faAtom","faBaby","faBacterium","faBahai","faBaseballBall","faBasketballBall","faBrain","faCannabis","faCandyCane","faCarrot","faChartPie","faChessKing","faChessKnight","faCloudMeatball","faCookieBite","faCrosshairs","faCrown","faDharmachakra","faDiceD20","faDisease","faDizzy","faDragon","faFeather","faFingerprint","faFistRaised","faGem","faGhost","faHeadphones","faHelicopter","faIgloo","faInfinity","faJedi","faFootballBall","faFutbol","faLemon","faLifeRing","faLightbulb","faMagnet","faMeteor","faPepperHot","faPoo","faPuzzlePiece","faRadiation","faRobot","faShoePrints","faShapes","faExclamation","faTimes","Tile","props","index","icon","onClick","tileWidth","finder","classes","className","data-testid","style","flexGrow","flexShrink","flexBasis","fixedWidth","Board","tileList","defaultIcon","col","useState","setTileWidth","containerWidth","setContainerWidth","useEffect","Math","ceil","width","map","tile","i","enabled","key","iconList","getRandomInt","max","floor","random","initBoard","rows","cols","tiles","icons","sort","slice","counter","positionHolders","Array","fill","position","newTilelist","length","randomPos","found","matchId","splice","isMatchFound","turnedTiles","filter","calculateWinner","row","matches","App","setTileList","isValidGrid","setIsValidGrid","isGameStarted","setIsGameStarted","isTileTurned","setIsTileTurned","isProcessing","setIsProcessing","turn","setTurn","p1Score","setP1Score","p2Score","setP2Score","setRow","setCol","setMatches","winner","handleOnChange","e","target","id","value","parseInt","display","htmlFor","onChange","type","newList","foundTiles","setTimeout","flippedTiles","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.452f6a6d.chunk.js","sourcesContent":["// Imports\r\nimport {library} from '@fortawesome/fontawesome-svg-core'\r\n// Import the necessary icons\r\nimport {\r\n    faBomb,\r\n    faBiohazard,\r\n    faAngry,\r\n    faAnkh,\r\n    faAtom,\r\n    faBaby,\r\n    faBacterium,\r\n    faBahai,\r\n    faBaseballBall,\r\n    faBasketballBall,\r\n    faBrain,\r\n    faCannabis,\r\n    faCandyCane,\r\n    faCarrot,\r\n    faChartPie,\r\n    faChessKing,\r\n    faChessKnight,\r\n    faCloudMeatball,\r\n    faCookieBite,\r\n    faCrosshairs,\r\n    faCrown,\r\n    faDharmachakra,\r\n    faDiceD20,\r\n    faDisease,\r\n    faDizzy,\r\n    faDragon,\r\n    faFeather,\r\n    faFingerprint,\r\n    faFistRaised,\r\n    faGem,\r\n    faGhost,\r\n    faHeadphones,\r\n    faHelicopter,\r\n    faIgloo,\r\n    faInfinity,\r\n    faJedi,\r\n    faFootballBall,\r\n    faFutbol,\r\n    faLemon,\r\n    faLifeRing,\r\n    faLightbulb,\r\n    faMagnet,\r\n    faMeteor,\r\n    faPepperHot,\r\n    faPoo,\r\n    faPuzzlePiece,\r\n    faRadiation,\r\n    faRobot,\r\n    faShoePrints,\r\n    faShapes,\r\n    faExclamation,\r\n    faTimes\r\n} from '@fortawesome/free-solid-svg-icons'\r\n\r\n// Add the icons to the library for use\r\nlibrary.add(\r\n    faBomb,\r\n    faBiohazard,\r\n    faAngry,\r\n    faAnkh,\r\n    faAtom,\r\n    faBaby,\r\n    faBacterium,\r\n    faBahai,\r\n    faBaseballBall,\r\n    faBasketballBall,\r\n    faBrain,\r\n    faCannabis,\r\n    faCandyCane,\r\n    faCarrot,\r\n    faChartPie,\r\n    faChessKing,\r\n    faChessKnight,\r\n    faCloudMeatball,\r\n    faCookieBite,\r\n    faCrosshairs,\r\n    faCrown,\r\n    faDharmachakra,\r\n    faDiceD20,\r\n    faDisease,\r\n    faDizzy,\r\n    faDragon,\r\n    faFeather,\r\n    faFingerprint,\r\n    faFistRaised,\r\n    faGem,\r\n    faGhost,\r\n    faHeadphones,\r\n    faHelicopter,\r\n    faIgloo,\r\n    faInfinity,\r\n    faJedi,\r\n    faFootballBall,\r\n    faFutbol,\r\n    faLemon,\r\n    faLifeRing,\r\n    faLightbulb,\r\n    faMagnet,\r\n    faMeteor,\r\n    faPepperHot,\r\n    faPoo,\r\n    faPuzzlePiece,\r\n    faRadiation,\r\n    faRobot,\r\n    faShoePrints,\r\n    faShapes,\r\n    faExclamation,\r\n    faTimes\r\n    );","// Imports\r\nimport React from 'react'\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\r\n\r\n// Tile component for individual tiles\r\nfunction Tile(props){\r\n    // icon is the design and onClick is the handler\r\n    const { index, icon, onClick, tileWidth, finder } = props\r\n\r\n    // Add a class to differentiate the regular tile from revealed tile\r\n    let classes = \"tile\"\r\n    classes += icon === \"exclamation\" ? \" default-tile\" : \"\"\r\n    classes += finder === \"\" ? \"\" : \" \" + finder\r\n    \r\n    // Just a plain button with a onClick event\r\n    return (\r\n        <button className={classes} data-testid={index} onClick={onClick} style={{flexGrow: 0, flexShrink: 0, flexBasis: `${tileWidth}%`}}>\r\n            <FontAwesomeIcon data-testid={icon} icon={icon} fixedWidth/>\r\n        </button>\r\n    )\r\n}\r\n\r\n// Exporting the created component\r\nexport default Tile","// Imports\r\nimport React, { useEffect, useState } from 'react'\r\nimport Tile from './Tile'\r\n\r\n// Board component to hold all the boxes\r\nfunction Board(props) {\r\n    // tileList is an array of all boxes and onClick is the handler\r\n    const { tileList, onClick, defaultIcon, col } = props\r\n\r\n    // useState Hooks\r\n    const [tileWidth, setTileWidth] = useState(0)\r\n    const [containerWidth, setContainerWidth] = useState(0)\r\n\r\n    // useEffect Hook\r\n    useEffect(() => {\r\n        // function calculates the width of container and the flex basis property\r\n        let width = 80 * col\r\n        setContainerWidth(width)\r\n        setTileWidth(Math.ceil((100 / col) * 1000) / 1000)\r\n    }, [col])\r\n\r\n    // Add all the boxes with an index to keep track of the box that was click\r\n    return (\r\n        <div style={{width : containerWidth}} className=\"board\">\r\n            {\r\n                // Map the tileList prop to set the corresponding values in each tile\r\n                tileList.map((tile, i) => {\r\n                    let { icon, enabled } = tile\r\n                    return (\r\n                        <Tile key={i} index={i} icon={enabled ? icon : defaultIcon} onClick={() => {\r\n                            onClick(i)\r\n                        }} tileWidth={tileWidth} finder={tile.finder} />\r\n                    )\r\n                })\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\n// Export the created component\r\nexport default Board","// List of font awesome icons we can use for the tiles\r\nconst iconList = [\r\n    \"bomb\",\r\n    \"biohazard\",\r\n    \"angry\",\r\n    \"ankh\",\r\n    \"atom\",\r\n    \"baby\",\r\n    \"bacterium\",\r\n    \"bahai\",\r\n    \"baseball-ball\",\r\n    \"basketball-ball\",\r\n    \"brain\",\r\n    \"cannabis\",\r\n    \"candy-cane\",\r\n    \"carrot\",\r\n    \"chart-pie\",\r\n    \"chess-king\",\r\n    \"chess-knight\",\r\n    \"cloud-meatball\",\r\n    \"cookie-bite\",\r\n    \"crosshairs\",\r\n    \"crown\",\r\n    \"dharmachakra\",\r\n    \"dice-d20\",\r\n    \"disease\",\r\n    \"dizzy\",\r\n    \"dragon\",\r\n    \"feather\",\r\n    \"fingerprint\",\r\n    \"fist-raised\",\r\n    \"gem\",\r\n    \"ghost\",\r\n    \"headphones\",\r\n    \"helicopter\",\r\n    \"igloo\",\r\n    \"infinity\",\r\n    \"jedi\",\r\n    \"football-ball\",\r\n    \"futbol\",\r\n    \"lemon\",\r\n    \"life-ring\",\r\n    \"lightbulb\",\r\n    \"magnet\",\r\n    \"meteor\",\r\n    \"pepper-hot\",\r\n    \"poo\",\r\n    \"puzzle-piece\",\r\n    \"radiation\",\r\n    \"robot\",\r\n    \"shoe-prints\",\r\n    \"shapes\"\r\n]\r\n\r\n// export the created list\r\nexport default iconList","// Imports\r\nimport iconList from '../data/iconList'\r\n\r\n\r\n// Get Random Postiion\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * Math.floor(max))\r\n}\r\n\r\n// Initialize random positions for the icons list\r\nfunction initBoard(rows, cols) {\r\n    const tiles = rows * cols\r\n    const icons = iconList.sort(() => Math.random() - 0.5).slice(0, tiles / 2)\r\n    let counter = 0\r\n    let positionHolders = Array(tiles).fill(null).map((position) => {\r\n        return counter++;\r\n    })\r\n\r\n    let newTilelist = Array(tiles).fill(null)\r\n    for (let i = 0; i < icons.length; i++) {\r\n        // Determine first position for the icon\r\n        let randomPos = getRandomInt(positionHolders.length)\r\n        let position1 = positionHolders[randomPos]\r\n        newTilelist[position1] = {\r\n            icon: icons[i],\r\n            enabled: false,\r\n            found: false,\r\n            finder: \"\",\r\n            matchId: i\r\n        }\r\n        positionHolders.splice(randomPos, 1)\r\n\r\n        // Determine second position for the icon\r\n        randomPos = getRandomInt(positionHolders.length)\r\n        let position2 = positionHolders[randomPos]\r\n        newTilelist[position2] = {\r\n            icon: icons[i],\r\n            enabled: false,\r\n            found: false,\r\n            finder: \"\",\r\n            matchId: i\r\n        }\r\n        positionHolders.splice(randomPos, 1)\r\n    }\r\n\r\n    // return the initialized board\r\n    return newTilelist\r\n}\r\n\r\n// Export the created function\r\nexport default initBoard","// Find the enabled tiles and check their matchId and return a boolean if matched\r\nfunction isMatchFound(tileList){\r\n    // Filter tiles that are enabled and not marked as found\r\n    const turnedTiles = tileList.filter((tile) => {\r\n        if (tile.enabled && !tile.found){\r\n            return tile\r\n        }\r\n    })\r\n\r\n    // Check if the tiles enabled have same matchId\r\n    if (turnedTiles[0].matchId === turnedTiles[1].matchId)\r\n        return true\r\n    return false\r\n}\r\n\r\n// Export the created function\r\nexport default isMatchFound","// Check the match count to the total matches possible and return a boolean\r\nfunction calculateWinner(row, col, matches) {\r\n    return (row * col / 2) === matches\r\n}\r\n\r\n// Export the created function\r\nexport default calculateWinner","// Imports\r\nimport React, { useState } from 'react';\r\nimport './App.css';\r\nimport './fontawesome'\r\nimport Board from './components/Board';\r\nimport initBoard from './helpers/initializeBoard'\r\nimport isMatchFound from './helpers/isMatchFound'\r\nimport calculateWinner from './helpers/calculateWinner'\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\n\r\n// App Component\r\nfunction App() {\r\n  // Default Icon to be displayed when the tiles are not turned around\r\n  const defaultIcon = \"exclamation\"\r\n\r\n  // useState Hooks\r\n  const [tileList, setTileList] = useState([])\r\n  const [isValidGrid, setIsValidGrid] = useState(true)\r\n  const [isGameStarted, setIsGameStarted] = useState(false)\r\n  const [isTileTurned, setIsTileTurned] = useState(false)\r\n  const [isProcessing, setIsProcessing] = useState(false)\r\n  const [turn, setTurn] = useState(\"p1\")\r\n  const [p1Score, setP1Score] = useState(0)\r\n  const [p2Score, setP2Score] = useState(0)\r\n  const [row, setRow] = useState(2)\r\n  const [col, setCol] = useState(2)\r\n  const [matches, setMatches] = useState(0)\r\n\r\n  // Check for Winner after every move\r\n  const winner = calculateWinner(row, col, matches)\r\n\r\n  // Set the default state\r\n  function initializeBoard() {\r\n    setTileList(initBoard(row, col))\r\n    setIsGameStarted(true)\r\n  }\r\n\r\n  // flip the turned over tiles\r\n  function flipTiles() {\r\n    return tileList.map((tile) => {\r\n      if (tile.found) {\r\n        return tile\r\n      }\r\n      return {\r\n        icon: tile.icon,\r\n        enabled: false,\r\n        found: tile.found,\r\n        finder: tile.finder,\r\n        matchId: tile.matchId\r\n      }\r\n    })\r\n  }\r\n\r\n  // Handle the clicks on the tiles and process further\r\n  function handleClick(i) {\r\n    // Should be handled only if the tile is not turned over, there is no winner\r\n    // The tiles are turned back in settimeout thus, no clicks to be handled during that time\r\n    if (tileList[i].enabled || isProcessing || winner) return\r\n\r\n    // Change the enabled to true for the selected tile\r\n    const newList = tileList.map((tile, index) => {\r\n      if (index === i) {\r\n        return {\r\n          icon: tile.icon,\r\n          enabled: true,\r\n          found: tile.found,\r\n          finder: tile.finder,\r\n          matchId: tile.matchId\r\n        }\r\n      }\r\n      return tile\r\n    })\r\n    // Check if a tile is already turned if so check for match and if not then just turn the tile\r\n    if (isTileTurned) {\r\n      // Check for match if any\r\n      if (isMatchFound(newList)) {\r\n        // Add the score according to the turn of the player\r\n        if (turn === \"p1\") {\r\n          setP1Score(p1Score + 1)\r\n        }\r\n        else {\r\n          setP2Score(p2Score + 1)\r\n        }\r\n        // Update the tiles that are found and set the found boolean to true and add the finder\r\n        const foundTiles = newList.map((tile) => {\r\n          if (tile.enabled && !tile.found) {\r\n            return {\r\n              icon: tile.icon,\r\n              enabled: tile.enabled,\r\n              found: true,\r\n              finder: turn,\r\n              matchId: tile.matchId\r\n            }\r\n          }\r\n          return tile\r\n        })\r\n        // Set the states of the new board and increment the match count after every match\r\n        // This is done to keep track of the game over state\r\n        setIsTileTurned(false)\r\n        setTileList(foundTiles)\r\n        setMatches(matches + 1)\r\n        // This is gameplay dependent logic\r\n        // If this line is commented then player finding a match will continue the turn\r\n        // If not then turns are switched irrespective of the match found\r\n        //setTurn(turn === \"p1\" ? \"p2\" : \"p1\")\r\n      }\r\n      else {\r\n        // Change the tiles to the previous state after one second so as to show what was underneath the tile\r\n        setIsProcessing(true)\r\n        setTileList(newList)\r\n        setTimeout(() => {\r\n          const flippedTiles = flipTiles()\r\n          setIsTileTurned(false)\r\n          setTileList(flippedTiles)\r\n          setIsProcessing(false)\r\n          setTurn(turn === \"p1\" ? \"p2\" : \"p1\")\r\n        }, 1000)\r\n      }\r\n    }\r\n    else {\r\n      // Turn the tile over and continue\r\n      setIsTileTurned(true)\r\n      setTileList(newList)\r\n    }\r\n  }\r\n\r\n  // Handle the change of the grid size and check for the grid validitiy\r\n  function handleOnChange(e) {\r\n    let { id, value } = e.target\r\n    value = parseInt(value)\r\n    if (id === \"row\") {\r\n      // Grid is valid only if the cells are even and the cell count >= 4\r\n      setIsValidGrid(((col % 2 !== 0 && value % 2 !== 0) || col * value < 4 || col * value > 100) ? false : true)\r\n      setRow(value)\r\n    }\r\n    else {\r\n      setIsValidGrid(((row % 2 !== 0 && value % 2 !== 0) || row * value < 4 || row * value > 100) ? false : true)\r\n      setCol(value)\r\n    }\r\n  }\r\n\r\n  // Handle the reset button click and set everything to the default state except the grid size\r\n  function handleReset() {\r\n    setIsGameStarted(false)\r\n    setTileList([])\r\n    setIsValidGrid(true)\r\n    setP1Score(0)\r\n    setP2Score(0)\r\n    setTurn(\"p1\")\r\n    setMatches(0)\r\n  }\r\n\r\n  return (\r\n    <div className=\"app\">\r\n      <h1>Memory Game</h1>\r\n      <div style={{ display: !isGameStarted ? \"block\" : \"none\" }}>\r\n        <div>\r\n          {/* Select the size of the grid to be played (Max is 100 Tiles) */}\r\n          <h3>Select Grid Size</h3>\r\n          <label htmlFor=\"row\">Row</label>\r\n          <input data-testid=\"row\" className=\"grid-input\" onChange={handleOnChange} id=\"row\" type=\"number\" value={row} />\r\n          <FontAwesomeIcon icon={\"times\"} fixedWidth />\r\n          <input data-testid=\"col\" className=\"grid-input\" onChange={handleOnChange} id=\"col\" type=\"number\" value={col} />\r\n          <label htmlFor=\"col\">Col</label>\r\n        </div>\r\n        {/* Show error message if the grid is invalid */}\r\n        <h4 data-testid=\"error\" className=\"error\" style={{ display: !isValidGrid ? \"block\" : \"none\" }}>The Grid Entered had odd number of cells or the cell count is not between 4 and 100</h4>\r\n        {/* Show the start game button only when the grid is valid */}\r\n        <button data-testid=\"start\" className=\"button start\" style={{ display: isValidGrid ? \"inline-block\" : \"none\" }} onClick={initializeBoard}>Start Game!</button>\r\n      </div>\r\n      <div className=\"game\" style={{ display: isGameStarted ? \"block\" : \"none\" }}>\r\n        <div>\r\n          <div>\r\n            {/* The score of the players are displayed here */}\r\n            <h3>Score:-</h3>\r\n            <h4 className=\"score\">Player 1 : <span className=\"p1\">{p1Score}</span></h4>\r\n            <h4 className=\"score\">Player 2 : <span className=\"p2\">{p2Score}</span></h4>\r\n          </div>\r\n        </div>\r\n        <div>\r\n          <h2>Board</h2>\r\n          <div>\r\n            {/* On basis of winner or turn display appropriate message */}\r\n            <h3>{winner ? p1Score === p2Score ? \"Game is a draw!\" : p1Score > p2Score ? \"Player 1 Wins!\" : \"Player 2 Wins!\" : turn === \"p1\" ? \"Player 1's Turn\" : \"Player 2's Turn\"}</h3>\r\n          </div>\r\n          <Board tileList={tileList} onClick={handleClick} defaultIcon={defaultIcon} col={col} />\r\n        </div>\r\n        {/* Reset the state again after the game is completed */}\r\n        <button className=\"button reset\" onClick={handleReset} style={{ display: winner ? \"inline-block\" : \"none\" }}>Reset!</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Export the created component\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}